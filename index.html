<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>SAMAY</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500;600&display=swap" rel="stylesheet"/>
<style>
*, *::before, *::after { box-sizing:border-box; margin:0; padding:0; }
:root {
  --bg: #edecea;
  --text: #1c1c1c;
  --text-mid: #555;
  --text-light: #bbb;
  --accent: #2D5A27;
  --accent2: #3A86FF;
  --font: 'DM Sans', sans-serif;
}
html, body { width:100%; height:100%; overflow:hidden; background:var(--bg); font-family:var(--font); }

body::after {
  content:''; position:fixed; inset:0;
  background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 300 300' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.035'/%3E%3C/svg%3E");
  pointer-events:none; z-index:900; opacity:0.45;
}

.scene { width:100%; height:100%; position:relative; display:flex; align-items:center; justify-content:center; }

.orb-wrap {
  position:absolute; width:280px; height:280px; top:50%; left:50%;
  transform:translate(-50%, -54%) scale(1); transform-origin: top left;
  transition: top .72s cubic-bezier(.65,0,.35,1), left .72s cubic-bezier(.65,0,.35,1),
              transform .72s cubic-bezier(.65,0,.35,1), opacity .5s;
  z-index:20; cursor:pointer;
}
.scene.active  .orb-wrap { top:22px; left:18px; transform:translate(0,0) scale(0.1714); }
.scene.calendar .orb-wrap { top:22px; left:18px; transform:translate(0,0) scale(0.1714); }

.orb {
  position:relative; width:100%; height:100%; border-radius:50%; overflow:hidden;
  -webkit-mask-image: radial-gradient(circle, black 49%, transparent 50%);
  mask-image: radial-gradient(circle, black 49%, transparent 50%);
  animation: orbFloat 7s ease-in-out infinite, orbBreath 8s ease-in-out infinite;
  filter: drop-shadow(0 0 40px rgba(58,134,255,0.20)) drop-shadow(0 20px 48px rgba(0,0,0,0.22));
  transition: filter .5s;
}
.scene.active .orb, .scene.calendar .orb {
  animation: orbFloatMini 5s ease-in-out infinite;
  filter: drop-shadow(0 2px 10px rgba(0,0,0,0.25));
}
@keyframes orbFloat    { 0%,100%{transform:translateY(0)}  50%{transform:translateY(-13px)} }
@keyframes orbFloatMini{ 0%,100%{transform:translateY(0)}  50%{transform:translateY(-3px)}  }
@keyframes orbBreath   { 0%,100%{transform:scale(1)} 33%{transform:scale(1.012)} 66%{transform:scale(0.995)} }

.orb-base { position:absolute; inset:0; background:radial-gradient(ellipse at 45% 55%, #1a3d16 0%, #0d2a0a 45%, #060f05 100%); }
.blobs { position:absolute; inset:-20%; width:140%; height:140%; filter:blur(48px) saturate(1.4); will-change:transform; }
.blob  { position:absolute; border-radius:50%; mix-blend-mode:screen; will-change:transform; }
.blob-1 { width:75%; height:75%; top:5%; left:0%; background:radial-gradient(circle,#4a9a3e 0%,#2D5A27 45%,transparent 72%); animation:blob1 18s ease-in-out infinite; opacity:.92; }
@keyframes blob1 { 0%{transform:translate(0%,0%) scale(1)} 20%{transform:translate(18%,12%) scale(1.08)} 40%{transform:translate(28%,-5%) scale(0.95)} 60%{transform:translate(10%,22%) scale(1.12)} 80%{transform:translate(-8%,8%) scale(1.04)} 100%{transform:translate(0%,0%) scale(1)} }
.blob-2 { width:70%; height:70%; top:20%; left:28%; background:radial-gradient(circle,#6ba3ff 0%,#3A86FF 40%,transparent 68%); animation:blob2 14s ease-in-out infinite; opacity:.85; }
@keyframes blob2 { 0%{transform:translate(0%,0%) scale(1)} 25%{transform:translate(-22%,15%) scale(1.10)} 50%{transform:translate(-8%,30%) scale(0.92)} 75%{transform:translate(15%,12%) scale(1.06)} 100%{transform:translate(0%,0%) scale(1)} }
.blob-3 { width:80%; height:65%; top:45%; left:10%; background:radial-gradient(circle,#e8ff9a 0%,#D4FC79 35%,#8ab82a 65%,transparent 78%); animation:blob3 22s ease-in-out infinite; opacity:.70; }
@keyframes blob3 { 0%{transform:translate(0%,0%) scale(1)} 30%{transform:translate(15%,-20%) scale(1.15)} 55%{transform:translate(-10%,-8%) scale(0.90)} 80%{transform:translate(8%,18%) scale(1.08)} 100%{transform:translate(0%,0%) scale(1)} }
.blob-4 { width:45%; height:45%; top:30%; left:38%; background:radial-gradient(circle,#7adc5e 0%,#3d8c2a 50%,transparent 70%); animation:blob4 10s ease-in-out infinite; opacity:.60; }
@keyframes blob4 { 0%{transform:translate(0%,0%) scale(1)} 20%{transform:translate(-30%,-20%) scale(1.20)} 40%{transform:translate(20%,-30%) scale(0.85)} 60%{transform:translate(25%,20%) scale(1.15)} 80%{transform:translate(-15%,25%) scale(0.92)} 100%{transform:translate(0%,0%) scale(1)} }
.blob-5 { width:55%; height:55%; top:0%; left:40%; background:radial-gradient(circle,#a8d4ff 0%,#5a9eff 30%,#2D5A27 65%,transparent 78%); animation:blob5 16s ease-in-out infinite reverse; opacity:.55; }
@keyframes blob5 { 0%{transform:translate(0%,0%) scale(1)} 25%{transform:translate(-20%,30%) scale(1.12)} 50%{transform:translate(10%,20%) scale(0.88)} 75%{transform:translate(20%,-10%) scale(1.10)} 100%{transform:translate(0%,0%) scale(1)} }
.blob-6 { width:50%; height:50%; top:55%; left:45%; background:radial-gradient(circle,#1a5ccc 0%,#0a2f80 55%,transparent 72%); animation:blob6 20s ease-in-out infinite; opacity:.75; mix-blend-mode:hard-light; }
@keyframes blob6 { 0%{transform:translate(0%,0%) scale(1)} 35%{transform:translate(-25%,-15%) scale(1.18)} 65%{transform:translate(15%,-25%) scale(0.88)} 100%{transform:translate(0%,0%) scale(1)} }
.orb-vignette { position:absolute; inset:0; border-radius:50%; background:radial-gradient(circle at 50% 50%,transparent 50%,rgba(0,0,0,0.45) 80%,rgba(0,0,0,0.75) 100%); pointer-events:none; }
.orb-grain { position:absolute; inset:0; background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='300'%3E%3Cfilter id='g'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.72' numOctaves='4' seed='2' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='300' height='300' filter='url(%23g)' opacity='1'/%3E%3C/svg%3E"); background-size:220px 220px; mix-blend-mode:overlay; opacity:.55; animation:grainShift .8s steps(1) infinite; pointer-events:none; }
@keyframes grainShift { 0%{background-position:0 0} 10%{background-position:-55px -25px} 20%{background-position:30px 60px} 30%{background-position:-80px 10px} 40%{background-position:20px -70px} 50%{background-position:-40px 50px} 60%{background-position:70px -30px} 70%{background-position:-10px 80px} 80%{background-position:50px -50px} 90%{background-position:-60px 20px} 100%{background-position:0 0} }
.orb-svg-grain { position:absolute; inset:0; pointer-events:none; opacity:.30; mix-blend-mode:soft-light; }
.orb-gloss { position:absolute; top:6%; left:8%; width:48%; height:38%; border-radius:50%; background:radial-gradient(ellipse at 35% 30%,rgba(255,255,255,0.28) 0%,rgba(255,255,255,0.08) 45%,transparent 70%); filter:blur(8px); pointer-events:none; animation:glossShift 12s ease-in-out infinite; }
@keyframes glossShift { 0%,100%{transform:translate(0%,0%) scale(1); opacity:.9} 40%{transform:translate(4%,6%) scale(1.1); opacity:1} 70%{transform:translate(-3%,2%) scale(.92); opacity:.8} }

/* ══ STATE 1 — IDLE ══ */
.idle-bar {
  position:absolute; bottom:56px; left:50%; transform:translateX(-50%);
  display:flex; align-items:center; gap:10px;
  z-index:30; opacity:1; pointer-events:all;
  transition:opacity .3s, transform .3s;
}
.scene.active .idle-bar, .scene.calendar .idle-bar, .scene.connecting .idle-bar {
  opacity:0; pointer-events:none; transform:translateX(-50%) translateY(10px);
}
.btn-phone {
  width:50px; height:50px; border-radius:50%; border:none; background:#fff;
  box-shadow:0 1px 8px rgba(0,0,0,0.10),0 0 0 1px rgba(0,0,0,0.05);
  cursor:pointer; flex-shrink:0; display:flex; align-items:center; justify-content:center;
  transition:background .15s, transform .15s;
}
.btn-phone:hover { background:#f5f5f5; transform:scale(1.04); }
.btn-phone svg { color:#111; }
.input-idle {
  width:240px; padding:13px 20px; border-radius:100px; border:none; background:#fff;
  box-shadow:0 1px 8px rgba(0,0,0,0.09),0 0 0 1px rgba(0,0,0,0.05);
  font-family:var(--font); font-size:15px; color:var(--text); outline:none;
  transition:box-shadow .2s;
}
.input-idle::placeholder { color:var(--text-light); }
.input-idle:focus { box-shadow:0 2px 16px rgba(0,0,0,0.12),0 0 0 1px rgba(0,0,0,0.08); }

/* ══ CONNECTING STATE ══ */
.connecting-ui {
  position:absolute; bottom:56px; left:50%; transform:translateX(-50%) translateY(10px);
  display:flex; flex-direction:column; align-items:center; gap:14px;
  z-index:30; opacity:0; pointer-events:none;
  transition:opacity .35s, transform .35s;
}
.scene.connecting .connecting-ui { opacity:1; pointer-events:none; transform:translateX(-50%) translateY(0); }

.orb-ring {
  position:absolute; width:280px; height:280px; border-radius:50%;
  border:1.5px solid rgba(58,134,255,0.35); top:50%; left:50%;
  transform:translate(-50%,-54%) scale(1); opacity:0; pointer-events:none; z-index:15;
}
.scene.connecting .orb-ring { animation: ripple 2.2s ease-out infinite; }
.scene.connecting .orb-ring:nth-child(2) { animation-delay:.55s; border-color:rgba(45,154,62,0.28); }
.scene.connecting .orb-ring:nth-child(3) { animation-delay:1.1s; border-color:rgba(212,252,121,0.22); }
@keyframes ripple {
  0%   { transform:translate(-50%,-54%) scale(1);   opacity:.8; }
  100% { transform:translate(-50%,-54%) scale(1.55); opacity:0; }
}

.conn-pill {
  background:rgba(255,255,255,0.88); backdrop-filter:blur(12px);
  border:1px solid rgba(0,0,0,0.07); border-radius:100px; padding:10px 22px;
  display:flex; align-items:center; gap:10px;
  box-shadow:0 4px 24px rgba(0,0,0,0.10); white-space:nowrap;
}
.conn-dot-wrap { display:flex; align-items:center; gap:4px; }
.conn-dot { width:5px; height:5px; border-radius:50%; background:var(--accent2); animation:connBounce 1.1s ease-in-out infinite; }
.conn-dot:nth-child(2){animation-delay:.18s; background:var(--accent);}
.conn-dot:nth-child(3){animation-delay:.36s; background:#8ab82a;}
@keyframes connBounce { 0%,80%,100%{transform:translateY(0); opacity:.4;} 40%{transform:translateY(-5px); opacity:1;} }
.conn-label { font-size:13.5px; font-weight:500; color:var(--text-mid); letter-spacing:0.1px; }

.btn-cancel {
  width:38px; height:38px; border-radius:50%; border:none; background:rgba(255,255,255,0.75);
  box-shadow:0 1px 8px rgba(0,0,0,0.10); cursor:pointer; display:flex; align-items:center; justify-content:center;
  transition:background .15s, transform .12s; backdrop-filter:blur(8px);
}
.btn-cancel:hover { background:#fff; transform:scale(1.06); }
.btn-cancel svg { color:#aaa; }

/* ══ STATE 2 — ACTIVE ══ */
.convo-area {
  position:absolute; inset:0; display:flex; flex-direction:column;
  padding:90px 28px 90px 24px; opacity:0; pointer-events:none;
  transition:opacity .42s .26s; z-index:10;
}
.scene.active .convo-area { opacity:1; pointer-events:all; }
.scene.calendar .convo-area { opacity:0 !important; pointer-events:none !important; }
.transcript { flex:1; overflow-y:auto; display:flex; flex-direction:column; gap:18px; }
.transcript::-webkit-scrollbar { display:none; }
.msg { font-size:16px; line-height:1.68; color:var(--text); max-width:92%; animation:msgIn .38s cubic-bezier(.16,1,.3,1) both; }
.msg.user { align-self:flex-end; font-size:15px; color:var(--text-mid); }
.msg.ai   { align-self:flex-start; }
@keyframes msgIn { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
.typing { display:flex; gap:5px; align-items:center; padding:3px 0; opacity:0; pointer-events:none; transition:opacity .22s; align-self:flex-start; }
.typing.show { opacity:1; }
.typing span { width:7px; height:7px; border-radius:50%; background:var(--text-light); animation:td 1.2s ease-in-out infinite; }
.typing span:nth-child(2){animation-delay:.18s} .typing span:nth-child(3){animation-delay:.36s}
@keyframes td { 0%,80%,100%{transform:translateY(0);opacity:.35} 40%{transform:translateY(-6px);opacity:1} }
.active-bar {
  position:absolute; bottom:28px; left:24px; right:24px;
  display:flex; align-items:center; gap:10px;
  z-index:30; opacity:0; transform:translateY(10px); pointer-events:none;
  transition:opacity .35s .22s, transform .35s .22s;
}
.scene.active .active-bar { opacity:1; transform:translateY(0); pointer-events:all; }
.scene.calendar .active-bar { opacity:0 !important; pointer-events:none !important; }
.btn-hangup {
  width:50px; height:50px; border-radius:50%; border:none; background:#fff;
  box-shadow:0 1px 8px rgba(0,0,0,0.10),0 0 0 1px rgba(0,0,0,0.05);
  cursor:pointer; flex-shrink:0; display:flex; align-items:center; justify-content:center;
  transition:background .15s, transform .15s;
}
.btn-hangup:hover { background:#f5f5f5; transform:scale(1.04); }
.btn-hangup svg { color:#111; }
.input-active {
  flex:1; padding:13px 20px; border-radius:100px;
  border:1.5px solid rgba(60,130,220,0.55); background:#fff;
  font-family:var(--font); font-size:15px; color:var(--text); outline:none;
  box-shadow:0 0 0 3px rgba(60,130,220,0.09); transition:border-color .2s, box-shadow .2s;
}
.input-active::placeholder { color:var(--text-light); }
.input-active:focus { border-color:rgba(60,130,220,0.72); box-shadow:0 0 0 4px rgba(60,130,220,0.13); }

/* ══ STATE 3 — CALENDAR ══ */
.cal-backdrop {
  position:absolute; inset:0;
  background: radial-gradient(ellipse at 20% 50%, rgba(106,163,255,0.15) 0%, transparent 50%),
              radial-gradient(ellipse at 80% 60%, rgba(74,154,62,0.12) 0%, transparent 50%),
              radial-gradient(ellipse at 55% 5%,  rgba(212,252,121,0.10) 0%, transparent 40%),
              #ece9e4;
  opacity:0; pointer-events:none; transition:opacity .5s .1s; z-index:9990;
}
.scene.calendar .cal-backdrop { opacity:1; }

.calendar-view {
  position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  opacity:0; pointer-events:none; transition:opacity .5s .1s; z-index:9999; padding-top:30px;
}
.scene.calendar .calendar-view { opacity:1; pointer-events:all; }

.cal-card {
  display:flex; width: min(90vw, 660px); height: min(75vh, 400px);
  border-radius:22px; overflow:hidden;
  box-shadow:0 12px 56px rgba(45,90,39,0.16),0 2px 10px rgba(0,0,0,0.08);
}
/* Removed @keyframes calIn — it was causing the card to be invisible on re-entry */

.cal-left {
  width:40%; flex-shrink:0;
  background: linear-gradient(155deg, #3d8430 0%, #2D5A27 50%, #1b3e17 100%);
  display:flex; flex-direction:column; padding:20px 16px 16px 16px;
  position:relative; overflow:hidden;
}
.cal-left::before {
  content:''; position:absolute; inset:0; pointer-events:none;
  background: radial-gradient(ellipse at 20% 20%, rgba(106,163,255,0.20) 0%, transparent 50%),
              radial-gradient(ellipse at 85% 85%, rgba(212,252,121,0.14) 0%, transparent 45%);
}
.cal-top-row { display:flex; align-items:center; justify-content:space-between; margin-bottom:16px; position:relative; z-index:1; }
.cal-month-label { font-size:15px; font-weight:600; color:rgba(255,255,255,0.95); letter-spacing:0.3px; }
.cal-nav-btn {
  width:26px; height:26px; border-radius:50%; border:none; background:rgba(255,255,255,0.14);
  cursor:pointer; display:flex; align-items:center; justify-content:center; transition:background .15s, transform .12s;
}
.cal-nav-btn:hover { background:rgba(255,255,255,0.26); transform:scale(1.1); }
.cal-nav-btn svg { color:rgba(255,255,255,0.88); }
.cal-dow { display:grid; grid-template-columns:repeat(7,1fr); margin-bottom:5px; position:relative; z-index:1; }
.cal-dow span { text-align:center; font-size:9px; font-weight:500; color:rgba(255,255,255,0.45); letter-spacing:.6px; text-transform:uppercase; }
.cal-grid { display:grid; grid-template-columns:repeat(7,1fr); gap:1px; flex:1; align-content:start; position:relative; z-index:1; }
.cal-day {
  aspect-ratio:1; border-radius:50%; display:flex; align-items:center; justify-content:center;
  cursor:pointer; position:relative; transition:background .14s, transform .12s;
  font-size:11.5px; font-weight:400; color:rgba(255,255,255,0.65);
}
.cal-day:hover:not(.empty) { background:rgba(255,255,255,0.10); }
.cal-day.empty { cursor:default; pointer-events:none; }
.cal-day.today { color:#fff; font-weight:600; background:rgba(255,255,255,0.16); }
.cal-day.has-event {
  background: radial-gradient(circle, #D4FC79 0%, #9fd43a 100%);
  color:#1a3d16; font-weight:700; box-shadow: 0 2px 12px rgba(212,252,121,0.50); cursor:pointer;
}
.cal-day.has-event:hover { transform:scale(1.14); }
.cal-day.today:not(.has-event)::after {
  content:''; position:absolute; bottom:3px; width:3px; height:3px; border-radius:50%; background:#D4FC79;
}
.cal-right { flex:1; background:#fff; display:flex; flex-direction:column; overflow:hidden; }
.cal-right-top {
  display:flex; align-items:center; justify-content:flex-end; padding:14px 16px 8px; gap:10px;
  border-bottom:1px solid rgba(0,0,0,0.05);
}
.cal-icon-btn {
  width:28px; height:28px; border-radius:50%; border:none; background:transparent;
  display:flex; align-items:center; justify-content:center; cursor:pointer; transition:background .15s;
}
.cal-icon-btn:hover { background:rgba(0,0,0,0.05); }
.cal-icon-btn svg { color:#bbb; }
.events-scroll { flex:1; overflow-y:auto; padding:6px 0 12px; }
.events-scroll::-webkit-scrollbar { display:none; }
.ev-empty { display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; gap:8px; color:#ccc; font-size:12.5px; }
.ev-empty svg { opacity:.25; }
.ev-row {
  display:flex; align-items:flex-start; gap:10px; padding:10px 16px; cursor:pointer;
  transition:background .14s; position:relative;
}
.ev-row:hover { background:rgba(45,90,39,0.04); }
.ev-row.future::before {
  content:''; position:absolute; left:0; top:10px; bottom:10px;
  width:3px; background:#D4FC79; border-radius:0 2px 2px 0;
}
.ev-date-label { min-width:42px; text-align:right; padding-top:1px; font-size:10.5px; font-weight:500; color:#bbb; flex-shrink:0; }
.ev-dot { width:26px; height:26px; border-radius:50%; flex-shrink:0; display:flex; align-items:center; justify-content:center; margin-top:1px; }
.ev-dot svg { width:12px; height:12px; color:#fff; }
.ev-body { flex:1; min-width:0; }
.ev-title { font-size:13px; font-weight:600; color:#1c1c1c; line-height:1.25; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.ev-time  { font-size:11px; color:#aaa; margin-top:1px; }
.ev-badge { align-self:flex-start; margin-top:3px; flex-shrink:0; padding:2px 8px; border-radius:100px; font-size:9.5px; font-weight:600; letter-spacing:.3px; }
.badge-done   { background:rgba(0,0,0,0.05); color:#bbb; }
.badge-future { background:rgba(212,252,121,0.30); color:#4a7a1a; }
.ev-divider { height:1px; background:rgba(0,0,0,0.05); margin:0 16px; }

/* ══ TOAST ══ */
.toast {
  position:fixed; bottom:24px; left:50%; transform:translateX(-50%) translateY(52px);
  background:rgba(18,18,18,0.84); backdrop-filter:blur(10px);
  color:#fff; padding:9px 20px; border-radius:100px; font-size:12.5px; z-index:999;
  transition:transform .35s cubic-bezier(.16,1,.3,1); white-space:nowrap;
}
.toast.show { transform:translateX(-50%) translateY(0); }
</style>
</head>
<body>

<svg style="position:absolute;width:0;height:0;overflow:hidden" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <filter id="orb-noise" x="0%" y="0%" width="100%" height="100%" color-interpolation-filters="sRGB">
      <feTurbulence type="fractalNoise" baseFrequency="0.65 0.68" numOctaves="4" seed="5" stitchTiles="stitch" result="noise">
        <animate attributeName="seed" values="5;12;7;19;3;5" dur="4s" repeatCount="indefinite"/>
      </feTurbulence>
      <feColorMatrix type="saturate" values="0" in="noise" result="grey"/>
      <feComponentTransfer in="grey" result="boosted">
        <feFuncR type="linear" slope="1.4" intercept="-0.2"/>
        <feFuncG type="linear" slope="1.4" intercept="-0.2"/>
        <feFuncB type="linear" slope="1.4" intercept="-0.2"/>
      </feComponentTransfer>
      <feBlend in="SourceGraphic" in2="boosted" mode="overlay" result="blended"/>
      <feComposite in="blended" in2="SourceGraphic" operator="in"/>
    </filter>
  </defs>
</svg>

<div class="scene" id="scene">
  <div class="orb-ring"></div>
  <div class="orb-ring"></div>
  <div class="orb-ring"></div>
  <div class="cal-backdrop"></div>

  <div class="orb-wrap" id="orbWrap">
    <div class="orb" id="orb">
      <div class="orb-base"></div>
      <div class="blobs" id="blobs">
        <div class="blob blob-1"></div><div class="blob blob-2"></div>
        <div class="blob blob-3"></div><div class="blob blob-4"></div>
        <div class="blob blob-5"></div><div class="blob blob-6"></div>
      </div>
      <div class="orb-vignette"></div>
      <div class="orb-grain"></div>
      <svg class="orb-svg-grain" viewBox="0 0 280 280" xmlns="http://www.w3.org/2000/svg">
        <rect width="280" height="280" fill="white" filter="url(#orb-noise)" opacity="0.6"/>
      </svg>
      <div class="orb-gloss"></div>
    </div>
  </div>

  <!-- STATE 1: IDLE -->
  <div class="idle-bar" id="idleBar">
    <button class="btn-phone" id="callBtn">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M6.62 10.79a15.05 15.05 0 006.59 6.59l2.2-2.2a1 1 0 011.01-.25 11.36 11.36 0 003.56.57 1 1 0 011 1V20a1 1 0 01-1 1A17 17 0 013 4a1 1 0 011-1h3.5a1 1 0 011 1c0 1.25.2 2.45.57 3.57a1 1 0 01-.25 1.01l-2.2 2.21z"/>
      </svg>
    </button>
    <input class="input-idle" id="idleInput" type="text" placeholder="Or type a message..." autocomplete="off"/>
  </div>

  <!-- CONNECTING UI -->
  <div class="connecting-ui" id="connectingUi">
    <div class="conn-pill">
      <div class="conn-dot-wrap">
        <div class="conn-dot"></div><div class="conn-dot"></div><div class="conn-dot"></div>
      </div>
      <span class="conn-label" id="connLabel">Connecting…</span>
    </div>
    <button class="btn-cancel" id="cancelBtn" title="Cancel">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
      </svg>
    </button>
  </div>

  <!-- STATE 2: ACTIVE -->
  <div class="convo-area">
    <div class="transcript" id="transcript">
      <div class="typing" id="typing"><span></span><span></span><span></span></div>
    </div>
  </div>
  <div class="active-bar">
    <button class="btn-hangup" id="hangupBtn">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M10.68 13.31a16 16 0 003.41 2.6l1.27-1.27a2 2 0 012.11-.45 12.84 12.84 0 002.81.7 2 2 0 012 2v3a2 2 0 01-2.18 2 19.79 19.79 0 01-8.63-3.07A19.42 19.42 0 013.43 9.64a19.86 19.86 0 01-3.07-8.67A2 2 0 012.18 0h3a2 2 0 012 1.72 12.84 12.84 0 00.7 2.81 2 2 0 01-.45 2.11L6.18 7.91"/>
        <line x1="1" y1="1" x2="23" y2="23"/>
      </svg>
    </button>
    <input class="input-active" id="activeInput" type="text" placeholder="Type a message..." autocomplete="off"/>
  </div>

  <!-- STATE 3: CALENDAR -->
  <div class="calendar-view" id="calendarView">
    <div class="cal-card">
      <div class="cal-left">
        <div class="cal-top-row">
          <button class="cal-nav-btn" onclick="changeMonth(-1)">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
          </button>
          <span class="cal-month-label" id="calMonthLabel"></span>
          <button class="cal-nav-btn" onclick="changeMonth(1)">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.8" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
          </button>
        </div>
        <div class="cal-dow">
          <span>S</span><span>M</span><span>T</span><span>W</span><span>T</span><span>F</span><span>S</span>
        </div>
        <div class="cal-grid" id="calGrid"></div>
      </div>
      <div class="cal-right">
        <div class="cal-right-top">
          <button class="cal-icon-btn">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
          </button>
          <button class="cal-icon-btn">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="19" cy="12" r="1"/><circle cx="5" cy="12" r="1"/></svg>
          </button>
        </div>
        <div class="events-scroll" id="eventsScroll">
          <div class="ev-empty" id="evEmpty">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="18" rx="2"/>
              <line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/>
              <line x1="3" y1="10" x2="21" y2="10"/>
            </svg>
            <span>No events scheduled</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* ════════════════════
   CONFIG
════════════════════ */
const ASSISTANT_ID = "f08de70a-4804-440d-89b1-5c6463f00a65";
const PUBLIC_KEY   = "1135bec2-5e08-4bdb-854e-1a311db0ff0b";

/* ════════════════════
   STATE
════════════════════ */
let vapi = null;
let VapiClass = null;
let appState = 'idle';
let scheduledEvent = null;
let calYear  = new Date().getFullYear();
let calMonth = new Date().getMonth();
let lastUserUtterance  = ''; // tracks what user said by voice
let lastMeetingTitle   = '';   // populated when tool fires
let lastMeetingDate    = null; // populated when tool fires
let lastMeetingTime    = null; // populated when tool fires
let pendingEvent       = null; // full event object ready to show

/* ════════════════════
   ELEMENTS
════════════════════ */
const scene        = document.getElementById("scene");
const transcript   = document.getElementById("transcript");
const typing       = document.getElementById("typing");
const activeInput  = document.getElementById("activeInput");
const idleInput    = document.getElementById("idleInput");
const callBtn      = document.getElementById("callBtn");
const hangupBtn    = document.getElementById("hangupBtn");
const cancelBtn    = document.getElementById("cancelBtn");
const blobs        = document.getElementById("blobs");
const toastEl      = document.getElementById("toast");
const calGrid      = document.getElementById("calGrid");
const calLabel     = document.getElementById("calMonthLabel");
const eventsScroll = document.getElementById("eventsScroll");
const evEmpty      = document.getElementById("evEmpty");
const connLabel    = document.getElementById("connLabel");

/* ════════════════════
   PARALLAX
════════════════════ */
let mx=0,my=0,tx=0,ty=0;
document.addEventListener('mousemove',e=>{
  const r=document.getElementById("orb").getBoundingClientRect();
  mx=(e.clientX-r.left-r.width/2)/(r.width/2);
  my=(e.clientY-r.top-r.height/2)/(r.height/2);
});
(function orbTick(){
  tx+=(mx-tx)*0.04; ty+=(my-ty)*0.04;
  if(appState==='idle') blobs.style.transform=`translate(calc(-20% + ${tx*10}px),calc(-20% + ${ty*8}px))`;
  else blobs.style.transform='';
  requestAnimationFrame(orbTick);
})();

/* ════════════════════
   HELPERS
════════════════════ */
function showToast(msg, d=3000){
  toastEl.textContent = msg;
  toastEl.classList.add("show");
  setTimeout(()=> toastEl.classList.remove("show"), d);
}

function setState(s){
  appState = s;
  scene.classList.remove('active','connecting','calendar');
  if(s === 'connecting') scene.classList.add('connecting');
  if(s === 'active')     scene.classList.add('active');
  if(s === 'calendar')   scene.classList.add('calendar');
  console.log('[SAMAY] state →', s, '| scene classes:', scene.className);
}

function goConnecting(){ connLabel.textContent='Connecting…'; setState('connecting'); }
function goActive(){ setState('active'); setTimeout(()=>activeInput.focus(), 680); }
function goIdle(){
  vapi = null;
  setState('idle');
  Array.from(transcript.children).forEach(c=>{ if(c!==typing) c.remove(); });
  typing.classList.remove("show");
  activeInput.value = "";
}
function goCalendar(event){
  console.log('[SAMAY] goCalendar called with:', event);
  scheduledEvent = event;
  calYear  = event.date.getFullYear();
  calMonth = event.date.getMonth();
  renderCalendar();
  renderEvents();
  setState('calendar');
}

/* ════════════════════
   TRANSCRIPT
════════════════════ */
function showTyping(v){
  transcript.appendChild(typing);
  typing.classList.toggle("show", v);
  transcript.scrollTop = transcript.scrollHeight;
}
function addMsg(role, text){
  if(transcript.contains(typing)) transcript.removeChild(typing);
  const d = document.createElement("div");
  d.className = "msg " + role;
  d.textContent = text;
  transcript.appendChild(d);
  transcript.appendChild(typing);
  transcript.scrollTop = transcript.scrollHeight;
}
function typeWrite(text, speed=14){
  return new Promise(res=>{
    if(transcript.contains(typing)) transcript.removeChild(typing);
    const d = document.createElement("div");
    d.className = "msg ai";
    transcript.appendChild(d);
    transcript.appendChild(typing);
    let i = 0;
    const tick = ()=>{
      if(i < text.length){ d.textContent += text[i++]; transcript.scrollTop=9999; setTimeout(tick, speed); }
      else res();
    };
    tick();
  });
}

/* ════════════════════
   DATE PARSER
════════════════════ */
function parseScheduleFromUserInput(text){
  const months = {
    jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11,
    january:0,february:1,march:2,april:3,june:5,july:6,august:7,september:8,
    october:9,november:10,december:11
  };
  const today = new Date();
  let eventDate = null;

  // Named month match
  const dm = text.match(/\b(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?\b/i) ||
             text.match(/\b(\d{1,2})(?:st|nd|rd|th)?\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)\b/i);
  if(dm){
    let mStr, day;
    if(isNaN(dm[1])){ mStr=dm[1].toLowerCase(); day=parseInt(dm[2]); }
    else             { day=parseInt(dm[1]);       mStr=dm[2].toLowerCase(); }
    const mIdx = months[mStr];
    if(mIdx !== undefined && day >= 1 && day <= 31){
      eventDate = new Date(today.getFullYear(), mIdx, day);
      if(eventDate < today) eventDate.setFullYear(today.getFullYear()+1);
    }
  }

  const lower = text.toLowerCase();
  if(!eventDate && lower.includes('tomorrow')){ eventDate = new Date(today); eventDate.setDate(today.getDate()+1); }
  if(!eventDate && lower.includes('next week')){ eventDate = new Date(today); eventDate.setDate(today.getDate()+7); }
  if(!eventDate && lower.includes('today')){ eventDate = new Date(today); }

  if(!eventDate) return null;

  // Time
  const tm = text.match(/\b(\d{1,2})(?::(\d{2}))?\s*(am|pm)\b/i) ||
             text.match(/\bat\s+(\d{1,2})(?::(\d{2}))?\b/i);
  let time = null;
  if(tm){ const h=tm[1],m=tm[2]||'00',ap=tm[3]||''; time=`${h}:${m}${ap?' '+ap.toUpperCase():''}`; }

  // Title
  const q  = text.match(/"([^"]+)"/);
  const kw = text.match(/\b(meeting|call|session|interview|appointment|standup|review|demo|lunch|dinner|coffee|sync|workshop|webinar|presentation|consultation)\b/i);
  const title = q ? q[1] : kw ? kw[0].charAt(0).toUpperCase()+kw[0].slice(1) : 'Scheduled Event';

  return { title, date: eventDate, time, gcalLink: null };
}

function parseScheduleFromAIResponse(aiText){
  const lower = aiText.toLowerCase();

  // Broad confirmation detection — catches almost any scheduling confirmation
  const confirmWords = [
    'scheduled','booking','booked','set up','confirmed','added','created',
    "i've","i have","all set","you're set","you are set","got you","got it",
    'great','perfect','sure','done','noted','registered','arranged','locked in',
    'penciled','set for','down for','set on'
  ];
  const hasConfirmation = confirmWords.some(w => lower.includes(w));

  // Try to parse a date from the AI response first
  let ev = parseScheduleFromUserInput(aiText);

  // If no date in AI response, fall back to what the USER said
  if(!ev && lastUserUtterance) {
    ev = parseScheduleFromUserInput(lastUserUtterance);
  }

  // Only return if we have EITHER a confirmation word OR a parseable date
  // (voice agents sometimes confirm without repeating the date)
  if(!hasConfirmation && !ev) return null;
  return ev;
}

/* ════════════════════
   CALENDAR RENDER
════════════════════ */
const MONTHS_SHORT = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function renderCalendar(){
  const today = new Date();
  const firstDay = new Date(calYear, calMonth, 1).getDay();
  const daysInMonth = new Date(calYear, calMonth+1, 0).getDate();
  calLabel.textContent = `${MONTHS_SHORT[calMonth]}. ${calYear}`;
  calGrid.innerHTML = '';
  for(let i=0;i<firstDay;i++){
    const e=document.createElement('div'); e.className='cal-day empty'; calGrid.appendChild(e);
  }
  for(let d=1;d<=daysInMonth;d++){
    const cell = document.createElement('div'); cell.className = 'cal-day';
    cell.textContent = d;
    const isToday = d===today.getDate() && calMonth===today.getMonth() && calYear===today.getFullYear();
    if(isToday) cell.classList.add('today');
    if(scheduledEvent){
      const ev = scheduledEvent.date;
      if(d===ev.getDate() && calMonth===ev.getMonth() && calYear===ev.getFullYear()){
        cell.classList.add('has-event');
        cell.addEventListener('click', openGoogleCalendar);
      }
    }
    calGrid.appendChild(cell);
  }
}

window.changeMonth = function(dir){
  calMonth += dir;
  if(calMonth>11){ calMonth=0; calYear++; }
  if(calMonth<0) { calMonth=11; calYear--; }
  renderCalendar();
};

/* ════════════════════
   EVENTS RENDER
════════════════════ */
function renderEvents(){
  Array.from(eventsScroll.children).forEach(c=>{ if(c!==evEmpty) c.remove(); });
  if(!scheduledEvent){ evEmpty.style.display='flex'; return; }
  evEmpty.style.display = 'none';
  const ev = scheduledEvent;
  const isFuture = ev.date >= new Date();
  const dateLabel = ev.date.toLocaleDateString('en-US',{month:'short',day:'numeric'});

  const row = document.createElement('div');
  row.className = 'ev-row' + (isFuture?' future':'');
  row.onclick = openGoogleCalendar;
  row.innerHTML = `
    <div class="ev-date-label">${dateLabel}</div>
    <div class="ev-dot" style="background:#2D5A27">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="4" width="18" height="18" rx="2"/>
        <line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/>
      </svg>
    </div>
    <div class="ev-body">
      <div class="ev-title">${ev.title}</div>
      <div class="ev-time">${ev.time||'All day'}</div>
    </div>
    <div class="ev-badge ${isFuture?'badge-future':'badge-done'}">${isFuture?'Upcoming':'Done'}</div>
  `;
  eventsScroll.appendChild(row);

  const divider = document.createElement('div'); divider.className='ev-divider';
  eventsScroll.appendChild(divider);

  const open = document.createElement('div');
  open.className = 'ev-row'; open.onclick = openGoogleCalendar;
  open.innerHTML = `
    <div class="ev-date-label"></div>
    <div class="ev-dot" style="background:#3A86FF">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/>
        <polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/>
      </svg>
    </div>
    <div class="ev-body">
      <div class="ev-title" style="color:#3A86FF">Open in Google Calendar</div>
      <div class="ev-time">Tap to view &amp; edit</div>
    </div>
  `;
  eventsScroll.appendChild(open);
}

/* ════════════════════
   GOOGLE CALENDAR
════════════════════ */
window.openGoogleCalendar = function(){
  if(!scheduledEvent) return;

  // If we have the actual event link from backend — go straight to it
  if(scheduledEvent.gcalLink){
    window.open(scheduledEvent.gcalLink, '_blank');
    return;
  }

  // Otherwise build a view URL for the correct date (not create-event)
  const ev = scheduledEvent, d = ev.date;
  const pad = n => String(n).padStart(2,'0');
  // Build day view URL: shows the specific day with the event visible
  const dateStr = `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())}`;
  window.open(`https://calendar.google.com/calendar/r/day/${dateStr}`, '_blank');
};

/* ════════════════════
   TEXT FALLBACK
════════════════════ */
function handleTextInput(text){
  addMsg("user", text);
  const lower = text.toLowerCase();

  if(lower.match(/schedule|book|set.?up|meeting|appointment|call|remind/)){
    showTyping(true);
    setTimeout(async ()=>{
      const ev = parseScheduleFromUserInput(text);
      const response = ev
        ? `Got it! I've scheduled "${ev.title}" for ${ev.date.toLocaleDateString('en-US',{month:'long',day:'numeric',year:'numeric'})}${ev.time ? ' at '+ev.time : ''}. Opening your calendar now.`
        : `Sure! What date and time works for this?`;

      showTyping(false);
      await typeWrite(response);

      if(ev){
        // Short delay then go to calendar — total ~1.5s after typewrite finishes
        setTimeout(()=>{
          showToast(`✅ "${ev.title}" scheduled!`, 2500);
          setTimeout(()=> goCalendar(ev), 600);
        }, 400);
      }
    }, 800);
  } else {
    showTyping(true);
    setTimeout(async()=>{
      showTyping(false);
      await typeWrite("Tell me what you'd like to schedule — the event name, date, and time!");
    }, 800);
  }
}

/* ════════════════════
   SIMPLE DATE EXTRACTOR (for user speech)
════════════════════ */
function parseDateFromText(text){
  const months = {jan:0,feb:1,mar:2,apr:3,may:4,jun:5,jul:6,aug:7,sep:8,oct:9,nov:10,dec:11,
    january:0,february:1,march:2,april:3,june:5,july:6,august:7,september:8,october:9,november:10,december:11};
  const today = new Date();
  const lower = text.toLowerCase();
  let d = null;
  const dm = text.match(/\b(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|oct|nov|dec)\s+(\d{1,2})(?:st|nd|rd|th)?\b/i);
  if(dm){ const mIdx=months[dm[1].toLowerCase()],day=parseInt(dm[2]); if(mIdx!==undefined){ d=new Date(today.getFullYear(),mIdx,day); if(d<today)d.setFullYear(today.getFullYear()+1); } }
  if(!d&&lower.includes('tomorrow')){ d=new Date(today); d.setDate(today.getDate()+1); }
  if(!d&&lower.includes('next week')){ d=new Date(today); d.setDate(today.getDate()+7); }
  if(!d&&lower.includes('today')){ d=new Date(today); }
  return d;
}

/* ════════════════════
   VAPI — loaded async,
   does NOT block listeners
════════════════════ */
function loadVapi(){
  // Non-blocking — event listeners are already registered below
  import("./vapi-bundle.js").then(mod=>{
    VapiClass = mod.default ?? mod.Vapi ?? mod.VapiSDK;
    if(typeof VapiClass !== "function" && VapiClass?.default) VapiClass = VapiClass.default;
    console.log('[SAMAY] Vapi loaded:', typeof VapiClass);
  }).catch(()=>{
    console.warn('[SAMAY] vapi-bundle.js not found — text mode only');
  });
}

function wireVapi(){
  vapi.on("call-start", ()=> {
    console.log('[VAPI EVENT] call-start');
    goActive();
  });

  vapi.on("call-end", ()=> {
    console.log('[VAPI EVENT] call-end');
    showToast("Call ended");
    goIdle();
  });

  vapi.on("speech-start", ()=> {
    console.log('[VAPI EVENT] speech-start');
    showTyping(true);
  });

  vapi.on("speech-end", ()=> {
    console.log('[VAPI EVENT] speech-end');
    showTyping(false);
  });

  vapi.on("message", msg=>{
    console.log('[VAPI MESSAGE] type:', msg.type);

    // ── 1. TOOL CALL — agent called schedule_meeting ──
    // This is the ONLY reliable trigger: agent collected all info and called the tool
    if(msg.type === 'tool-calls' || msg.type === 'function-call'){
      const toolList = msg.toolCallList || (msg.functionCall ? [{ function: msg.functionCall }] : []);
      toolList.forEach(tool => {
        const fnName = (tool.function?.name || '').toLowerCase();
        console.log('[VAPI TOOL] called:', fnName, 'args:', tool.function?.arguments);
        if(fnName.includes('schedule') || fnName.includes('meeting') || fnName.includes('calendar') || fnName.includes('event') || fnName.includes('book')){
          let args = tool.function?.arguments || '{}';
          if(typeof args === 'string') { try { args = JSON.parse(args); } catch(e){ args = {}; } }
          console.log('[VAPI TOOL] schedule_meeting args:', args);
          let eventDate = null;
          if(args.date){
            eventDate = new Date(args.date + 'T00:00:00');
            if(isNaN(eventDate.getTime())) eventDate = null;
          }
          if(!eventDate) eventDate = new Date(Date.now() + 86400000);
          // Store as pendingEvent — calendar opens when MEETING_CONFIRMED keyword is spoken
          pendingEvent = {
            title: args.title || args.summary || args.eventName || args.meeting_title || 'Meeting',
            date:  eventDate,
            time:  args.time || args.startTime || args.meeting_time || null,
            gcalLink: args.link || args.htmlLink || null
          };
          lastMeetingTitle = pendingEvent.title;
          lastMeetingDate  = pendingEvent.date;
          lastMeetingTime  = pendingEvent.time;
          console.log('[VAPI TOOL] pendingEvent stored:', pendingEvent);
        }
      });
      return;
    }

    // ── 2. TOOL CALL RESULT — backend responded ──
    if(msg.type === 'tool-call-result' || msg.type === 'function-call-result'){
      console.log('[VAPI TOOL RESULT]', JSON.stringify(msg));
      // If backend returns event data in result, use that
      try {
        const result = typeof msg.result === 'string' ? JSON.parse(msg.result) : msg.result;
        if(result && (result.date || result.eventDate || result.htmlLink)){
          const ev = {
            title:   result.title || result.summary || result.eventName || 'Meeting',
            date:    result.date ? new Date(result.date) : new Date(Date.now() + 86400000),
            time:    result.time || result.startTime || null,
            gcalLink: result.htmlLink || result.link || null
          };
          console.log('[VAPI TOOL RESULT] → goCalendar:', ev);
          showToast('✅ Meeting scheduled!', 2500);
          setTimeout(()=> goCalendar(ev), 800);
        }
      } catch(e) { console.log('[VAPI TOOL RESULT] parse error:', e); }
      return;
    }

    // ── 3. TRANSCRIPT — show messages, but DO NOT parse dates here ──
    if(msg.type === "transcript" && msg.transcriptType === "final"){
      showTyping(false);
      addMsg(msg.role === "user" ? "user" : "ai", msg.transcript);
      // Track user's speech for reference only — no date parsing triggered here
      if(msg.role === "user"){
        lastUserUtterance = msg.transcript;
        console.log('[VAPI] User said:', msg.transcript);
      }
      if(msg.role === "assistant"){
        const text = msg.transcript;
        console.log('[VAPI] Assistant said:', text);

        // ── TRIGGER: agent says "MEETING_CONFIRMED" keyword ──
        // Add to Vapi system prompt:
        // "After calling schedule_meeting and confirming the booking, always say the exact word MEETING_CONFIRMED at the end."
        if(/MEETING.?CONFIRMED|meeting confirmed|booking confirmed|schedule confirmed/i.test(text)){
          console.log('[VAPI] ✅ MEETING_CONFIRMED detected in:', text);

          // ── Extract real Google Calendar event link from agent's speech ──
          // Agent reads the direct event URL — grab it so "Open" goes to the actual event
          // URLs in speech get transcribed with spaces, so we also check the full conversation
          let gcalLink = null;

          // Try to find a real https URL in the transcript
          const urlMatch = text.match(/https?:\/\/\S+/i);
          if(urlMatch) gcalLink = urlMatch[0];

          // Also check if pendingEvent has a link (from tool-call result)
          if(!gcalLink && pendingEvent?.gcalLink) gcalLink = pendingEvent.gcalLink;

          // ── Extract date from agent's final readback ──
          // Agent says "Date, two zero two six zero two two six" → transcribed as "20260226"
          let eventDate = null;

          // Match YYYYMMDD compact
          const compact = text.match(/(202\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])/);
          // Match YYYY-MM-DD
          const dashed  = text.match(/(202\d)-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])/);
          // Match YYYY MM DD with spaces
          const spaced  = text.match(/(202\d)\s+(0[1-9]|1[0-2])\s+(0[1-9]|[12]\d|3[01])/);

          const dm = compact || dashed || spaced;
          if(dm){
            eventDate = new Date(dm[1] + '-' + dm[2] + '-' + dm[3] + 'T00:00:00');
            if(isNaN(eventDate)) eventDate = null;
            console.log('[VAPI] Date from transcript:', dm[0], '→', eventDate);
          }

          // Fallback: use pendingEvent date (from tool call — most accurate)
          if(!eventDate && pendingEvent?.date) eventDate = pendingEvent.date;
          // Last fallback: parse from what user said
          if(!eventDate && lastUserUtterance) eventDate = parseDateFromText(lastUserUtterance);
          if(!eventDate) eventDate = new Date(Date.now() + 86400000);

          // ── Extract time from agent's readback ──
          // e.g. "Time, nine PM ST" or "9 AM IST"
          const timeMatch = text.match(/(\d{1,2})(?::(\d{2}))?\s*(AM|PM)/i);
          const time = timeMatch ? timeMatch[0] : (pendingEvent?.time || null);

          // ── Title: from pendingEvent (tool call args) or user's last utterance ──
          const title = pendingEvent?.title ||
            (lastUserUtterance && lastUserUtterance.length > 1 && lastUserUtterance.length < 60
              ? lastUserUtterance.charAt(0).toUpperCase() + lastUserUtterance.slice(1)
              : 'Meeting');

          const ev = { title, date: eventDate, time, gcalLink };
          console.log('[VAPI] → goCalendar:', ev);
          showToast('✅ Meeting scheduled!', 2000);
          setTimeout(()=> goCalendar(ev), 500);
          pendingEvent = null;
        }
      }
    }
  });

  vapi.on("error", err=>{
    console.log('[VAPI EVENT] error:', JSON.stringify(err));
    showToast("⚠ " + (err?.message || "Error"), 5000);
    goIdle(); vapi = null;
  });
}

async function startCall(){
  if(!VapiClass){ showToast("⚠ vapi-bundle.js not loaded yet — use text mode"); return; }
  if(vapi) return;
  goConnecting();
  try{
    vapi = new VapiClass(PUBLIC_KEY);
    wireVapi();
    await vapi.start(ASSISTANT_ID);
  } catch(e){
    showToast("⚠ " + (e.message || "Could not connect"));
    goIdle(); vapi = null;
  }
}

/* ════════════════════
   EVENT LISTENERS
   (registered immediately — no blocking await)
════════════════════ */
callBtn.addEventListener("click", startCall);

cancelBtn.addEventListener("click", ()=>{
  if(vapi) vapi.stop();
  goIdle();
});

idleInput.addEventListener("keydown", e=>{
  if(e.key === "Enter" && idleInput.value.trim()){
    const v = idleInput.value.trim();
    idleInput.value = "";
    setState('active');
    handleTextInput(v);
  }
});

activeInput.addEventListener("keydown", e=>{
  if(e.key === "Enter" && activeInput.value.trim()){
    const v = activeInput.value.trim();
    activeInput.value = "";
    if(vapi?.send){
      addMsg("user", v);
      vapi.send({ type:"add-message", message:{ role:"user", content:v } });
    } else {
      handleTextInput(v);
    }
  }
});

hangupBtn.addEventListener("click", ()=>{
  if(vapi) vapi.stop();
  goIdle();
});

/* ════════════════════
   INIT
════════════════════ */
renderCalendar();
loadVapi(); // fire and forget — doesn't block anything
</script>
</body>
</html>