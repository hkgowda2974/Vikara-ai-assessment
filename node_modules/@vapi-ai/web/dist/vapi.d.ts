import type { ChatCompletionMessageParam } from 'openai/resources';
import { DailyCall, DailyAdvancedConfig, DailyFactoryOptions, DailyParticipant, DailyVideoSendSettings } from '@daily-co/daily-js';
import EventEmitter from 'events';
import { Call, CreateSquadDTO, CreateAssistantDTO, AssistantOverrides, CreateWorkflowDTO, WorkflowOverrides } from './api';
export interface EndCallMessage {
    type: 'end-call';
}
export interface AddMessageMessage {
    type: 'add-message';
    message: ChatCompletionMessageParam;
    triggerResponseEnabled?: boolean;
}
export interface ControlMessages {
    type: 'control';
    control: 'mute-assistant' | 'unmute-assistant' | 'say-first-message';
    videoRecordingStartDelaySeconds?: number;
}
export interface SayMessage {
    type: 'say';
    message: string;
    endCallAfterSpoken?: boolean;
    interruptionsEnabled?: boolean;
    interruptAssistantEnabled?: boolean;
}
type VapiClientToServerMessage = AddMessageMessage | ControlMessages | SayMessage | EndCallMessage;
type VapiEventNames = 'call-end' | 'call-start' | 'volume-level' | 'speech-start' | 'speech-end' | 'message' | 'video' | 'error' | 'camera-error' | 'network-quality-change' | 'network-connection' | 'daily-participant-updated' | 'call-start-progress' | 'call-start-success' | 'call-start-failed';
interface CallStartProgressEvent {
    stage: string;
    status: 'started' | 'completed' | 'failed';
    duration?: number;
    timestamp: string;
    metadata?: Record<string, any>;
}
interface CallStartSuccessEvent {
    totalDuration: number;
    callId?: string;
    timestamp: string;
}
interface CallStartFailedEvent {
    stage: string;
    totalDuration: number;
    error: string;
    errorStack?: string;
    timestamp: string;
    context: Record<string, any>;
}
type VapiEventListeners = {
    'call-end': () => void;
    'call-start': () => void;
    'volume-level': (volume: number) => void;
    'speech-start': () => void;
    'speech-end': () => void;
    video: (track: MediaStreamTrack) => void;
    message: (message: any) => void;
    error: (error: any) => void;
    'camera-error': (error: any) => void;
    'network-quality-change': (event: any) => void;
    'network-connection': (event: any) => void;
    'daily-participant-updated': (participant: DailyParticipant) => void;
    'call-start-progress': (event: CallStartProgressEvent) => void;
    'call-start-success': (event: CallStartSuccessEvent) => void;
    'call-start-failed': (event: CallStartFailedEvent) => void;
};
type StartCallOptions = {
    /**
     * This determines whether the daily room will be deleted and all participants will be kicked once the user leaves the room.
     * If set to `false`, the room will be kept alive even after the user leaves, allowing clients to reconnect to the same room.
     * If set to `true`, the room will be deleted and reconnection will not be allowed.
     *
     * Defaults to `true`.
     * @example true
     */
    roomDeleteOnUserLeaveEnabled?: boolean;
};
type WebCall = {
    /**
     * The Vapi WebCall URL. This is the URL that the call will be joined on.
     *
     * call.webCallUrl or call.transport.callUrl
     */
    webCallUrl: string;
    /**
     * The Vapi WebCall ID. This is the ID of the call.
     *
     * call.id
     */
    id?: string;
    /**
     * The Vapi WebCall artifact plan. This is the artifact plan of the call.
     */
    artifactPlan?: {
        videoRecordingEnabled?: boolean;
    };
    /**
     * The Vapi WebCall assistant. This is the assistant of the call.
     *
     * call.assistant
     */
    assistant?: {
        voice?: {
            provider?: string;
        };
    };
};
declare class VapiEventEmitter extends EventEmitter {
    on<E extends VapiEventNames>(event: E, listener: VapiEventListeners[E]): this;
    once<E extends VapiEventNames>(event: E, listener: VapiEventListeners[E]): this;
    emit<E extends VapiEventNames>(event: E, ...args: Parameters<VapiEventListeners[E]>): boolean;
    removeListener<E extends VapiEventNames>(event: E, listener: VapiEventListeners[E]): this;
    removeAllListeners(event?: VapiEventNames): this;
}
export default class Vapi extends VapiEventEmitter {
    private started;
    private call;
    private speakingTimeout;
    private dailyCallConfig;
    private dailyCallObject;
    private hasEmittedCallEndedStatus;
    constructor(apiToken: string, apiBaseUrl?: string, dailyCallConfig?: Pick<DailyAdvancedConfig, 'avoidEval' | 'alwaysIncludeMicInPermissionPrompt'>, dailyCallObject?: Pick<DailyFactoryOptions, 'audioSource' | 'startAudioOff'>);
    private cleanup;
    private isMobileDevice;
    private sleep;
    start(assistant?: CreateAssistantDTO | string, assistantOverrides?: AssistantOverrides, squad?: CreateSquadDTO | string, workflow?: CreateWorkflowDTO | string, workflowOverrides?: WorkflowOverrides, options?: StartCallOptions): Promise<Call | null>;
    private onAppMessage;
    private handleRemoteParticipantsAudioLevel;
    /**
     * Stops the call by destroying the Daily call object.
     *
     * If `roomDeleteOnUserLeaveEnabled` is set to `false`, the Vapi call will be kept alive, allowing reconnections to the same call using the `reconnect` method.
     * If `roomDeleteOnUserLeaveEnabled` is set to `true`, the Vapi call will also be destroyed, preventing any reconnections.
     */
    stop(): Promise<void>;
    /**
     * Sends a Live Call Control message to the Vapi server.
     *
     * Docs: https://docs.vapi.ai/calls/call-features
     */
    send(message: VapiClientToServerMessage): void;
    setMuted(mute: boolean): void;
    isMuted(): boolean;
    say(message: string, endCallAfterSpoken?: boolean, interruptionsEnabled?: boolean, interruptAssistantEnabled?: boolean): void;
    /**
     * Ends the call immediately by sending a `end-call` message using Live Call Control, and destroys the Daily call object.
     *
     * This method always ends the call, regardless of the `roomDeleteOnUserLeaveEnabled` option.
     */
    end(): void;
    setInputDevicesAsync(options: Parameters<DailyCall['setInputDevicesAsync']>[0]): Promise<void>;
    increaseMicLevel(gain: number): Promise<void>;
    setOutputDeviceAsync(options: Parameters<DailyCall['setOutputDeviceAsync']>[0]): void;
    getDailyCallObject(): DailyCall | null;
    startScreenSharing(displayMediaOptions?: DisplayMediaStreamOptions, screenVideoSendSettings?: DailyVideoSendSettings): void;
    stopScreenSharing(): void;
    /**
     * Reconnects to an active call.
     *
     *
     * @param webCall
     */
    reconnect(webCall: WebCall): Promise<void>;
    /**
     * Runs all network connectivity tests for pre-call diagnostics.
     * Creates a temporary Daily call object for testing purposes.
     *
     * Tests performed:
     * 1. Network connectivity (TURN server) - Tests if traffic can be relayed through TURN servers
     * 2. Websocket connectivity - Tests if websocket connections can be established
     * 3. Call quality - Tests overall call quality metrics (if available in SDK version)
     *
     * @returns {Promise<Record<string, any>>} Test results object with status for each test
     *
     * @example
     * // Run pre-call network diagnostics
     * const results = await Vapi.runNetworkTestsStandalone();
     * if (results.networkConnectivity?.result === 'failed') {
     *   console.warn('Network issues detected - calls may not work properly');
     * }
     *
     * @static
     */
    static runNetworkTestsStandalone(): Promise<Record<string, any>>;
}
export {};
